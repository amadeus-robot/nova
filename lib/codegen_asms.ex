defmodule Nova.Compiler.CodeGenAssemblyScript do
  @moduledoc """
  First-pass code generator that turns a parsed Nova `Ast.Module`
  into valid AssemblyScript (≈ TypeScript-for-WASM) source.

  The threaded `env` carries:

    * `:namespace`  – AssemblyScript namespace / file-scope identifier.
    * `:generate_remote_calls` – if true, local calls become
      `${namespace}.${fn}` so snippets run in isolation (tests / REPL).

  """

  alias Nova.Compiler.Ast
  alias Nova.Compiler.Types.TCon

  # ──────────────────────────────────
  # Types & helpers
  # ──────────────────────────────────
  @type env :: %{
          namespace: String.t(),
          generate_remote_calls: boolean()
        }

  # sanitize_name(str) – replace Prime `'` etc. with legal JS id chars
  # to_as_modname/1 – map Nova module id → PascalCase filename/namespace

  defp sanitize_name(str) when is_binary(str) do
    str |> String.replace("'", "_prime")
  end

  defp to_as_modname(id) when is_binary(id) do
    id
    |> String.split(".")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join("")
  end

  defp indent(str, n) do
    pad = String.duplicate(" ", n)

    str
    |> String.split("\n")
    |> Enum.map_join("\n", fn
      "" -> ""
      line -> pad <> line
    end)
  end

  # String‑typed detection helpers – unchanged
  defp string_typed?(%Ast.Literal{type: :string}), do: true
  defp string_typed?(%{inferred_type: %TCon{name: :String}}), do: true
  defp string_typed?(%{inferred_type: %{name: :String}}), do: true
  defp string_typed?(_), do: false

  # ──────────────────────────────────
  # Public API
  # ──────────────────────────────────
  @spec compile(Ast.Module.t(), keyword()) :: String.t()
  def compile(%Ast.Module{name: name_ast, declarations: decls}, opts \\ []) do
    mod_name = to_as_modname(name_ast)

    env = %{
      namespace: mod_name,
      generate_remote_calls: Keyword.get(opts, :generate_remote_calls, false)
    }

    body_src =
      decls
      |> Enum.map(&compile_decl(&1, env))
      # drop no-ops
      |> Enum.reject(&(&1 == ""))
      |> Enum.join("\n\n")
      |> indent(0)

    """
    // AUTO-GENERATED BY Nova ⇒ AssemblyScript codegen
    // Module: #{mod_name}.as

    // --- prelude helpers (only once per file) ---------------------
    //   * placeholder for Effect.Console.log

    // --- user code -----------------------------------------------
    #{body_src}
    """
    |> String.trim()
  end

  @spec compile_expression(Ast.t(), keyword()) :: String.t()
  def compile_expression(expr, opts \\ []) do
    env = %{
      namespace: Keyword.get(opts, :namespace, "Tmp"),
      generate_remote_calls: Keyword.get(opts, :generate_remote_calls, false)
    }

    compile_expr(expr, env)
  end

  # ──────────────────────────────────
  # Declarations
  # ──────────────────────────────────
  defp compile_decl(
         %Ast.TypeAlias{name: id, type_vars: [], type: %Ast.RecordType{fields: f}},
         _env
       ) do
    # AssemblyScript record type ⇒ `interface` (erased at runtime)
    field_lines =
      for {label, _} <- f do
        # TODO: infer real AS type
        "  #{sanitize_name(label)}: any;"
      end

    """
    export interface #{to_as_modname(id)} {
    #{Enum.join(field_lines, "\n")}
    }
    """
  end

  defp compile_decl(%Ast.FunctionDeclaration{} = fun, env), do: compile_fun(fun, env)
  defp compile_decl(%Ast.ForeignImport{} = fi, _env), do: gen_foreign(fi)
  defp compile_decl(_other, _env), do: ""

  # ──────────────────────────────────
  # Functions
  # ──────────────────────────────────
  defp compile_fun(%Ast.FunctionDeclaration{name: n, parameters: ps, body: b}, env) do
    args = ps |> Enum.map(&compile_pattern(&1, env)) |> Enum.join(", ")
    body_src = compile_expr(b, env) |> indent(2)

    """
    export function #{sanitize_name(n)}(#{args}): void {   // TODO: type
    #{body_src}
    }
    """
  end

  # ──────────────────────────────────
  # Expressions  (env-aware)
  # ──────────────────────────────────
  # ❶ Literals -----------------------------------------------------
  defp compile_expr(%Ast.Literal{type: :number, value: v}, _), do: "#{v}"
  defp compile_expr(%Ast.Literal{type: :string, value: v}, _), do: ~s("#{v}")
  defp compile_expr(%Ast.Literal{type: :char, value: v}, _), do: "'#{v}'"
  # only inside patterns
  defp compile_expr(%Ast.Wildcard{}, _), do: "_"

  # ❷ Record literal ---------------------------------------------
  defp compile_expr(%Ast.RecordLiteral{fields: fs}, env) do
    pairs =
      fs
      |> Enum.map(fn {lbl, ex} -> "#{sanitize_name(lbl)}: #{compile_expr(ex, env)}" end)
      |> Enum.join(", ")

    "{ #{pairs} }"
  end

  # ❸ Identifiers -------------------------------------------------
  defp compile_expr(%Ast.Identifier{name: n}, _), do: sanitize_name(n)

  defp compile_expr(%Ast.QualifiedIdentifier{namespace: ns, name: n}, _),
    do: "#{sanitize_name(ns)}.#{sanitize_name(n)}"

  # ❹ Binary ops --------------------------------------------------
  defp compile_expr(%Ast.BinaryOp{op: "/=", left: l, right: r}, env),
    do: "(#{compile_expr(l, env)} !== #{compile_expr(r, env)})"

  defp compile_expr(%Ast.BinaryOp{op: "++", left: l, right: r}, env) do
    # strings → `+`, arrays → `.concat`
    if string_typed?(l) or string_typed?(r) do
      "#{compile_expr(l, env)} + #{compile_expr(r, env)}"
    else
      "#{compile_expr(l, env)}.concat(#{compile_expr(r, env)})"
    end
  end

  defp compile_expr(%Ast.BinaryOp{op: op, left: l, right: r}, env),
    do: "(#{compile_expr(l, env)} #{op} #{compile_expr(r, env)})"

  # ❺ Function call (env-aware) ----------------------------------
  defp compile_expr(%Ast.FunctionCall{function: f, arguments: as}, env) do
    f_code =
      case f do
        %Ast.Identifier{} ->
          base = compile_expr(f, env)
          if env.generate_remote_calls, do: "#{env.namespace}.#{base}", else: base

        _ ->
          "(" <> compile_expr(f, env) <> ")"
      end

    args = as |> Enum.map(&compile_expr(&1, env)) |> Enum.join(", ")
    "#{f_code}(#{args})"
  end

  # ❻ If-then-else -----------------------------------------------
  defp compile_expr(%Ast.IfExpression{condition: c, then_branch: t, else_branch: e}, env),
    do: "(#{compile_expr(c, env)} ? #{compile_expr(t, env)} : #{compile_expr(e, env)})"

  # ❼ Lambda ------------------------------------------------------
  defp compile_expr(%Ast.Lambda{parameters: ps, body: b}, env) do
    params = ps |> Enum.map(&compile_pattern(&1, env)) |> Enum.join(", ")
    "( (#{params}) => #{compile_expr(b, env)} )"
  end

  # ❽ Let binding → IIFE -----------------------------------------
  defp compile_expr(%Ast.LetBinding{bindings: bs, body: body}, env) do
    binding_lines =
      bs |> Enum.map(&compile_let_binding(&1, env)) |> Enum.join(";\n") |> indent(4)

    """
    (() => {
    #{binding_lines};
      return #{compile_expr(body, env)};
    })()
    """
  end

  # ❾ Case expression (poor-man’s `switch`) -----------------------
  defp compile_expr(%Ast.CaseExpression{expression: e, cases: cs}, env) do
    # Pseudocode: expand to chain of if-else since AS lacks pattern matching
    cond_chain =
      cs
      |> Enum.map(fn clause ->
        %{pattern: p, guard: g, body: b} = clause

        cond_str =
          case {compile_pattern(p, env), g} do
            # match() = runtime helper
            {pat, nil} -> "match(#{pat})"
            {pat, gexpr} -> "(match(#{pat}) && #{compile_expr(gexpr, env)})"
          end

        "if #{cond_str} { return #{compile_expr(b, env)} }"
      end)
      |> Enum.join(" else ")
      |> indent(2)

    """
    (() => {
    const ____scrut = #{compile_expr(e, env)};
    #{cond_chain};
    })()
    """
  end

  # ➓ Collections -------------------------------------------------
  defp compile_expr(%Ast.List{elements: es}, env),
    do: "[" <> Enum.map_join(es, ", ", &compile_expr(&1, env)) <> "]"

  defp compile_expr(%Ast.Tuple{elements: es}, env),
    # tuples as JS arrays
    do: "[" <> Enum.map_join(es, ", ", &compile_expr(&1, env)) <> "]"

  # ⓫ Fallback ----------------------------------------------------
  defp compile_expr(other, _),
    do: raise("Unsupported expression for AssemblyScript backend: #{inspect(other)}")

  # ──────────────────────────────────
  # Let-binding helpers
  # ──────────────────────────────────
  defp compile_let_binding({%Ast.Identifier{name: n}, v}, env),
    do: "let #{sanitize_name(n)} = #{compile_expr(v, env)}"

  defp compile_let_binding(
         {%Ast.FunctionCall{function: %Ast.Identifier{name: fname}, arguments: args}, val},
         env
       ) do
    params = args |> Enum.map(&compile_pattern(&1, env)) |> Enum.join(", ")

    """
    let #{sanitize_name(fname)} = (#{params}) => #{compile_expr(val, env)}
    """
  end

  # ──────────────────────────────────
  # Patterns  (very restricted in JS)
  # ──────────────────────────────────
  # For now only identifiers & literals; complex patterns are handled
  # by runtime helpers (`match()` above).
  defp compile_pattern(%Ast.Identifier{name: n}, _), do: sanitize_name(n)
  defp compile_pattern(%Ast.Literal{} = lit, env), do: compile_expr(lit, env)
  # placeholder
  defp compile_pattern(%Ast.Wildcard{}, _), do: "_"

  # ──────────────────────────────────
  # Foreign import
  # ──────────────────────────────────
  def gen_foreign(%Ast.ForeignImport{module: m, function: f, alias: name, type_signature: ts}) do
    arity = count_params(ts.type)
    args = for i <- 1..arity, do: "arg#{i}"

    """
    // foreign import #{m}.#{f}/#{arity}
    // AssemblyScript uses the `@external` decorator
    @external("#{m}", "#{f}")
    declare function #{sanitize_name(name)}(#{Enum.join(args, ", ")}): any;
    """
  end

  defp count_params(%Nova.Compiler.Ast.ForAllType{vars: _, type: t}), do: count_params(t)
  defp count_params(%Ast.BinaryOp{op: "->", right: r}), do: 1 + count_params(r)
  defp count_params(_), do: 0

end
